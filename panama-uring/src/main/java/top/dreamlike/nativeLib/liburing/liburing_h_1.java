// Generated by jextract

package top.dreamlike.nativeLib.liburing;

import top.dreamlike.helper.NativeCallException;
import top.dreamlike.helper.NativeHelper;
import top.dreamlike.helper.RuntimeHelper;

import java.lang.foreign.MemorySegment;
import java.lang.invoke.MethodHandle;

import static top.dreamlike.nativeLib.liburing.liburing_h.*;
class liburing_h_1 {

    public static MethodHandle io_uring_prep_timeout$MH() {
        return RuntimeHelper.requireNonNull(constants$30.io_uring_prep_timeout$MH, "io_uring_prep_timeout");
    }

    public static void io_uring_prep_timeout(MemorySegment sqe, MemorySegment ts, int count, int flags) {
        //static inline void io_uring_prep_timeout(struct io_uring_sqe *sqe,
        //					 struct __kernel_timespec *ts,
        //					 unsigned count, unsigned flags)
        //{
        //	io_uring_prep_rw(IORING_OP_TIMEOUT, sqe, -1, ts, 1, count);
        //	sqe->timeout_flags = flags;
        //}
        io_uring_prep_rw(IORING_OP_TIMEOUT(), sqe, -1, ts, 1, count);
        io_uring_sqe.timeout_flags$set(sqe, flags);
    }

    public static MethodHandle io_uring_prep_timeout_remove$MH() {
        return RuntimeHelper.requireNonNull(constants$30.io_uring_prep_timeout_remove$MH, "io_uring_prep_timeout_remove");
    }

    public static void io_uring_prep_timeout_remove(MemorySegment sqe, long user_data, int flags) {
        var mh$ = io_uring_prep_timeout_remove$MH();
        try {
            mh$.invokeExact(sqe, user_data, flags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MethodHandle io_uring_prep_timeout_update$MH() {
        return RuntimeHelper.requireNonNull(constants$31.io_uring_prep_timeout_update$MH, "io_uring_prep_timeout_update");
    }

    public static void io_uring_prep_timeout_update(MemorySegment sqe, MemorySegment ts, long user_data, int flags) {
        var mh$ = io_uring_prep_timeout_update$MH();
        try {
            mh$.invokeExact(sqe, ts, user_data, flags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MethodHandle io_uring_prep_accept$MH() {
        return RuntimeHelper.requireNonNull(constants$31.io_uring_prep_accept$MH, "io_uring_prep_accept");
    }

    public static void io_uring_prep_accept(MemorySegment sqe, int fd, MemorySegment addr, MemorySegment addrlen, int flags) {
        io_uring_prep_rw(IORING_OP_ACCEPT(), sqe, fd, addr, 0, addrlen.address());
        io_uring_sqe.accept_flags$set(sqe, flags);
    }

    public static void io_uring_prep_multishot_accept(MemorySegment sqe, int fd, MemorySegment addr, MemorySegment addrlen, int flags) {
        if (!NativeHelper.compareWithCurrentLinuxVersion(5, 19)) {
            throw new NativeCallException("need linux kernal > 5.19");
        }
        io_uring_prep_accept(sqe, fd, addr, addrlen, flags);
//        sqe->ioprio |= IORING_ACCEPT_MULTISHOT;
        MemorySegment sqeSegment = NativeHelper.unsafePointConvertor(sqe);
        short prio = io_uring_sqe.ioprio$get(sqeSegment);
        io_uring_sqe.ioprio$set(sqeSegment, (short) (prio | IORING_ACCEPT_MULTISHOT()));
    }


    public static MethodHandle io_uring_prep_cancel$MH() {
        return RuntimeHelper.requireNonNull(constants$31.io_uring_prep_cancel$MH, "io_uring_prep_cancel");
    }

    public static void io_uring_prep_cancel(MemorySegment sqe, MemorySegment user_data, int flags) {
        io_uring_prep_rw(IORING_OP_ASYNC_CANCEL(), sqe, -1, user_data, 0, 0);
        MemorySegment sqeSegment = NativeHelper.unsafePointConvertor(sqe);
        io_uring_sqe.cancel_flags$set(sqeSegment, flags);
    }

    /**
     * @param sqe
     * @param user_data user data
     * @param flags     IORING_ASYNC_CANCEL_ALL
     *                  Cancel all requests that match the given criteria, rather
     *                  than just canceling the first one found. Available since
     *                  5.19.
     *                  <p>
     *                  IORING_ASYNC_CANCEL_FD
     *                  Match based on the file descriptor used in the original
     *                  request rather than the user_data. This is what
     *                  io_uring_prep_cancel_fd(3) sets up. Available since 5.19.
     *                  <p>
     *                  IORING_ASYNC_CANCEL_ANY
     *                  Match any request in the ring, regardless of user_data or
     *                  file descriptor.  Can be used to cancel any pending
     *                  request in the ring. Available since 5.19.
     */
    public static void io_uring_prep_cancel(MemorySegment sqe, long user_data, int flags) {
        io_uring_prep_rw(IORING_OP_ASYNC_CANCEL(), sqe, -1, MemorySegment.ofAddress(user_data), 0, 0);
        MemorySegment sqeSegment = NativeHelper.unsafePointConvertor(sqe);
        io_uring_sqe.cancel_flags$set(sqeSegment, flags);
    }

    public static MethodHandle io_uring_prep_link_timeout$MH() {
        return RuntimeHelper.requireNonNull(constants$31.io_uring_prep_link_timeout$MH, "io_uring_prep_link_timeout");
    }

    public static void io_uring_prep_link_timeout(MemorySegment sqe, MemorySegment ts, int flags) {
        var mh$ = io_uring_prep_link_timeout$MH();
        try {
            mh$.invokeExact(sqe, ts, flags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MethodHandle io_uring_prep_connect$MH() {
        return RuntimeHelper.requireNonNull(constants$31.io_uring_prep_connect$MH, "io_uring_prep_connect");
    }

    public static void io_uring_prep_connect(MemorySegment sqe, int fd, MemorySegment addr, int addrlen) {
        io_uring_prep_rw(IORING_OP_CONNECT(), sqe, fd, addr, 0, addrlen);
    }

    public static MethodHandle io_uring_prep_files_update$MH() {
        return RuntimeHelper.requireNonNull(constants$31.io_uring_prep_files_update$MH, "io_uring_prep_files_update");
    }

    public static void io_uring_prep_files_update(MemorySegment sqe, MemorySegment fds, int nr_fds, int offset) {
        var mh$ = io_uring_prep_files_update$MH();
        try {
            mh$.invokeExact(sqe, fds, nr_fds, offset);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MethodHandle io_uring_prep_fallocate$MH() {
        return RuntimeHelper.requireNonNull(constants$32.io_uring_prep_fallocate$MH, "io_uring_prep_fallocate");
    }

    public static void io_uring_prep_fallocate(MemorySegment sqe, int fd, int mode, long offset, long len) {
        var mh$ = io_uring_prep_fallocate$MH();
        try {
            mh$.invokeExact(sqe, fd, mode, offset, len);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MethodHandle io_uring_prep_openat$MH() {
        return RuntimeHelper.requireNonNull(constants$32.io_uring_prep_openat$MH, "io_uring_prep_openat");
    }

    public static void io_uring_prep_openat(MemorySegment sqe, int dfd, MemorySegment path, int flags, int mode) {
        var mh$ = io_uring_prep_openat$MH();
        try {
            mh$.invokeExact(sqe, dfd, path, flags, mode);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MethodHandle io_uring_prep_close$MH() {
        return RuntimeHelper.requireNonNull(constants$32.io_uring_prep_close$MH, "io_uring_prep_close");
    }

    public static void io_uring_prep_close(MemorySegment sqe, int fd) {
        var mh$ = io_uring_prep_close$MH();
        try {
            mh$.invokeExact(sqe, fd);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MethodHandle io_uring_prep_read$MH() {
        return RuntimeHelper.requireNonNull(constants$32.io_uring_prep_read$MH, "io_uring_prep_read");
    }

    public static void io_uring_prep_read(MemorySegment sqe, int fd, MemorySegment buf, int nbytes, long offset) {
//        io_uring_prep_rw(IORING_OP_READ(), sqe, fd, buf, nbytes, offset);
        try {
            io_uring_prep_read$MH().invoke(sqe, fd, buf, nbytes, offset);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MethodHandle io_uring_prep_write$MH() {
        return RuntimeHelper.requireNonNull(constants$32.io_uring_prep_write$MH, "io_uring_prep_write");
    }

    public static void io_uring_prep_write(MemorySegment sqe, int fd, MemorySegment buf, int nbytes, long offset) {
        io_uring_prep_rw(IORING_OP_WRITE(), sqe, fd, buf, nbytes, offset);
    }

    public static MethodHandle io_uring_prep_statx$MH() {
        return RuntimeHelper.requireNonNull(constants$32.io_uring_prep_statx$MH, "io_uring_prep_statx");
    }

    public static void io_uring_prep_statx(MemorySegment sqe, int dfd, MemorySegment path, int flags, int mask, MemorySegment statxbuf) {
        var mh$ = io_uring_prep_statx$MH();
        try {
            mh$.invokeExact(sqe, dfd, path, flags, mask, statxbuf);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MethodHandle io_uring_prep_fadvise$MH() {
        return RuntimeHelper.requireNonNull(constants$33.io_uring_prep_fadvise$MH, "io_uring_prep_fadvise");
    }

    public static void io_uring_prep_fadvise(MemorySegment sqe, int fd, long offset, long len, int advice) {
        var mh$ = io_uring_prep_fadvise$MH();
        try {
            mh$.invokeExact(sqe, fd, offset, len, advice);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MethodHandle io_uring_prep_madvise$MH() {
        return RuntimeHelper.requireNonNull(constants$33.io_uring_prep_madvise$MH, "io_uring_prep_madvise");
    }

    public static void io_uring_prep_madvise(MemorySegment sqe, MemorySegment addr, long length, int advice) {
        var mh$ = io_uring_prep_madvise$MH();
        try {
            mh$.invokeExact(sqe, addr, length, advice);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MethodHandle io_uring_prep_send$MH() {
        return RuntimeHelper.requireNonNull(constants$33.io_uring_prep_send$MH, "io_uring_prep_send");
    }

    public static void io_uring_prep_send(MemorySegment sqe, int sockfd, MemorySegment buf, long len, int flags) {
        io_uring_prep_rw(IORING_OP_SEND(), sqe, sockfd, buf, (int) len, 0);
    }

    public static MethodHandle io_uring_prep_recv$MH() {
        return RuntimeHelper.requireNonNull(constants$33.io_uring_prep_recv$MH, "io_uring_prep_recv");
    }

    public static void io_uring_prep_recv_multi(MemorySegment sqe, int sockfd, MemorySegment buf, long len, int flags) {
        io_uring_prep_recv(sqe, sockfd, buf, len, flags);
        //io_uring_prep_recv(sqe, sockfd, buf, len, flags);
        //	sqe->ioprio |= IORING_RECV_MULTISHOT;
        short prio = io_uring_sqe.ioprio$get(sqe);
        io_uring_sqe.ioprio$set(sqe, (short) (prio | IORING_RECV_MULTISHOT()));
    }

    public static void io_uring_prep_recv(MemorySegment sqe, int sockfd, MemorySegment buf, long len, int flags) {
        io_uring_prep_rw(IORING_OP_RECV(), sqe, sockfd, buf, (int) len, 0);
    }

    public static MethodHandle io_uring_prep_openat2$MH() {
        return RuntimeHelper.requireNonNull(constants$33.io_uring_prep_openat2$MH, "io_uring_prep_openat2");
    }

    public static void io_uring_prep_openat2(MemorySegment sqe, int dfd, MemorySegment path, MemorySegment how) {
        var mh$ = io_uring_prep_openat2$MH();
        try {
            mh$.invokeExact(sqe, dfd, path, how);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MethodHandle io_uring_prep_epoll_ctl$MH() {
        return RuntimeHelper.requireNonNull(constants$33.io_uring_prep_epoll_ctl$MH, "io_uring_prep_epoll_ctl");
    }

    public static void io_uring_prep_epoll_ctl(MemorySegment sqe, int epfd, int fd, int op, MemorySegment ev) {
        var mh$ = io_uring_prep_epoll_ctl$MH();
        try {
            mh$.invokeExact(sqe, epfd, fd, op, ev);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MethodHandle io_uring_prep_provide_buffers$MH() {
        return RuntimeHelper.requireNonNull(constants$34.io_uring_prep_provide_buffers$MH, "io_uring_prep_provide_buffers");
    }

    public static void io_uring_prep_provide_buffers(MemorySegment sqe, MemorySegment addr, int len, int nr, int bgid, int bid) {
        io_uring_prep_rw(IORING_OP_PROVIDE_BUFFERS(), sqe, nr, addr, len, bid);
        io_uring_sqe.buf_group$set(NativeHelper.unsafePointConvertor(sqe), (short) bgid);
    }

    public static MethodHandle io_uring_prep_remove_buffers$MH() {
        return RuntimeHelper.requireNonNull(constants$34.io_uring_prep_remove_buffers$MH, "io_uring_prep_remove_buffers");
    }

    public static void io_uring_prep_remove_buffers(MemorySegment sqe, int nr, int bgid) {
        var mh$ = io_uring_prep_remove_buffers$MH();
        try {
            mh$.invokeExact(sqe, nr, bgid);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MethodHandle io_uring_prep_shutdown$MH() {
        return RuntimeHelper.requireNonNull(constants$34.io_uring_prep_shutdown$MH, "io_uring_prep_shutdown");
    }

    public static void io_uring_prep_shutdown(MemorySegment sqe, int fd, int how) {
        var mh$ = io_uring_prep_shutdown$MH();
        try {
            mh$.invokeExact(sqe, fd, how);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MethodHandle io_uring_prep_unlinkat$MH() {
        return RuntimeHelper.requireNonNull(constants$34.io_uring_prep_unlinkat$MH, "io_uring_prep_unlinkat");
    }

    public static void io_uring_prep_unlinkat(MemorySegment sqe, int dfd, MemorySegment path, int flags) {
        var mh$ = io_uring_prep_unlinkat$MH();
        try {
            mh$.invokeExact(sqe, dfd, path, flags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MethodHandle io_uring_prep_renameat$MH() {
        return RuntimeHelper.requireNonNull(constants$34.io_uring_prep_renameat$MH, "io_uring_prep_renameat");
    }

    public static void io_uring_prep_renameat(MemorySegment sqe, int olddfd, MemorySegment oldpath, int newdfd, MemorySegment newpath, int flags) {
        var mh$ = io_uring_prep_renameat$MH();
        try {
            mh$.invokeExact(sqe, olddfd, oldpath, newdfd, newpath, flags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MethodHandle io_uring_prep_sync_file_range$MH() {
        return RuntimeHelper.requireNonNull(constants$34.io_uring_prep_sync_file_range$MH, "io_uring_prep_sync_file_range");
    }

    public static void io_uring_prep_sync_file_range(MemorySegment sqe, int fd, int len, long offset, int flags) {
        var mh$ = io_uring_prep_sync_file_range$MH();
        try {
            mh$.invokeExact(sqe, fd, len, offset, flags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MethodHandle io_uring_sq_ready$MH() {
        return RuntimeHelper.requireNonNull(constants$35.io_uring_sq_ready$MH, "io_uring_sq_ready");
    }

    public static int io_uring_sq_ready(MemorySegment ring) {
        var mh$ = io_uring_sq_ready$MH();
        try {
            return (int) mh$.invokeExact(ring);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MethodHandle io_uring_sq_space_left$MH() {
        return RuntimeHelper.requireNonNull(constants$35.io_uring_sq_space_left$MH, "io_uring_sq_space_left");
    }

    public static int io_uring_sq_space_left(MemorySegment ring) {
        var mh$ = io_uring_sq_space_left$MH();
        try {
            return (int) mh$.invokeExact(ring);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MethodHandle io_uring_sqring_wait$MH() {
        return RuntimeHelper.requireNonNull(constants$35.io_uring_sqring_wait$MH, "io_uring_sqring_wait");
    }

    public static int io_uring_sqring_wait(MemorySegment ring) {
        var mh$ = io_uring_sqring_wait$MH();
        try {
            return (int) mh$.invokeExact(ring);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MethodHandle io_uring_cq_ready$MH() {
        return RuntimeHelper.requireNonNull(constants$35.io_uring_cq_ready$MH, "io_uring_cq_ready");
    }

    public static int io_uring_cq_ready(MemorySegment ring) {
        var mh$ = io_uring_cq_ready$MH();
        try {
            return (int) mh$.invokeExact(ring);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MethodHandle io_uring_cq_eventfd_enabled$MH() {
        return RuntimeHelper.requireNonNull(constants$35.io_uring_cq_eventfd_enabled$MH, "io_uring_cq_eventfd_enabled");
    }

    public static boolean io_uring_cq_eventfd_enabled(MemorySegment ring) {
        var mh$ = io_uring_cq_eventfd_enabled$MH();
        try {
            return (boolean) mh$.invokeExact(ring);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MethodHandle io_uring_cq_eventfd_toggle$MH() {
        return RuntimeHelper.requireNonNull(constants$35.io_uring_cq_eventfd_toggle$MH, "io_uring_cq_eventfd_toggle");
    }

    public static int io_uring_cq_eventfd_toggle(MemorySegment ring, boolean enabled) {
        var mh$ = io_uring_cq_eventfd_toggle$MH();
        try {
            return (int) mh$.invokeExact(ring, enabled);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MethodHandle io_uring_wait_cqe_nr$MH() {
        return RuntimeHelper.requireNonNull(constants$36.io_uring_wait_cqe_nr$MH, "io_uring_wait_cqe_nr");
    }

    public static int io_uring_wait_cqe_nr(MemorySegment ring, MemorySegment cqe_ptr, int wait_nr) {
        var mh$ = io_uring_wait_cqe_nr$MH();
        try {
            return (int) mh$.invokeExact(ring, cqe_ptr, wait_nr);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MethodHandle io_uring_peek_cqe$MH() {
        return RuntimeHelper.requireNonNull(constants$36.io_uring_peek_cqe$MH, "io_uring_peek_cqe");
    }

    public static int io_uring_peek_cqe(MemorySegment ring, MemorySegment cqe_ptr) {
        var mh$ = io_uring_peek_cqe$MH();
        try {
            return (int) mh$.invokeExact(ring, cqe_ptr);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MethodHandle io_uring_wait_cqe$MH() {
        return RuntimeHelper.requireNonNull(constants$36.io_uring_wait_cqe$MH, "io_uring_wait_cqe");
    }

    public static int io_uring_wait_cqe(MemorySegment ring, MemorySegment cqe_ptr) {
        var mh$ = io_uring_wait_cqe$MH();
        try {
            return (int) mh$.invokeExact(ring, cqe_ptr);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    public static long _POSIX_C_SOURCE() {
        return 199506L;
    }
    public static long __STDC_ISO_10646__() {
        return 201706L;
    }
    public static int __TIMESIZE() {
        return (int)64L;
    }
    public static int __PTHREAD_RWLOCK_ELISION_EXTRA() {
        return (int)0L;
    }
    public static int PF_UNIX() {
        return (int)1L;
    }
    public static int PF_FILE() {
        return (int)1L;
    }
    public static int PF_ROUTE() {
        return (int)16L;
    }
    public static int AF_UNSPEC() {
        return (int)0L;
    }
    public static int AF_LOCAL() {
        return (int)1L;
    }
    public static int AF_UNIX() {
        return (int)1L;
    }
    public static int AF_FILE() {
        return (int)1L;
    }
    public static int AF_INET() {
        return (int)2L;
    }
    public static int AF_AX25() {
        return (int)3L;
    }
    public static int AF_IPX() {
        return (int)4L;
    }
    public static int AF_APPLETALK() {
        return (int)5L;
    }
    public static int AF_NETROM() {
        return (int)6L;
    }
    public static int AF_BRIDGE() {
        return (int)7L;
    }
    public static int AF_ATMPVC() {
        return (int)8L;
    }
    public static int AF_X25() {
        return (int)9L;
    }
    public static int AF_INET6() {
        return (int)10L;
    }
    public static int AF_ROSE() {
        return (int)11L;
    }
    public static int AF_DECnet() {
        return (int)12L;
    }
    public static int AF_NETBEUI() {
        return (int)13L;
    }
    public static int AF_SECURITY() {
        return (int)14L;
    }
    public static int AF_KEY() {
        return (int)15L;
    }
    public static int AF_NETLINK() {
        return (int)16L;
    }
    public static int AF_ROUTE() {
        return (int)16L;
    }
    public static int AF_PACKET() {
        return (int)17L;
    }
    public static int AF_ASH() {
        return (int)18L;
    }
    public static int AF_ECONET() {
        return (int)19L;
    }
    public static int AF_ATMSVC() {
        return (int)20L;
    }
    public static int AF_RDS() {
        return (int)21L;
    }
    public static int AF_SNA() {
        return (int)22L;
    }
    public static int AF_IRDA() {
        return (int)23L;
    }
    public static int AF_PPPOX() {
        return (int)24L;
    }
    public static int AF_WANPIPE() {
        return (int)25L;
    }
    public static int AF_LLC() {
        return (int)26L;
    }
    public static int AF_IB() {
        return (int)27L;
    }
    public static int AF_MPLS() {
        return (int)28L;
    }
    public static int AF_CAN() {
        return (int)29L;
    }
    public static int AF_TIPC() {
        return (int)30L;
    }
    public static int AF_BLUETOOTH() {
        return (int)31L;
    }
    public static int AF_IUCV() {
        return (int)32L;
    }
    public static int AF_RXRPC() {
        return (int)33L;
    }
    public static int AF_ISDN() {
        return (int)34L;
    }
    public static int AF_PHONET() {
        return (int)35L;
    }
    public static int AF_IEEE802154() {
        return (int)36L;
    }
    public static int AF_CAIF() {
        return (int)37L;
    }
    public static int AF_ALG() {
        return (int)38L;
    }
    public static int AF_NFC() {
        return (int)39L;
    }
    public static int AF_VSOCK() {
        return (int)40L;
    }
    public static int AF_KCM() {
        return (int)41L;
    }
    public static int AF_QIPCRTR() {
        return (int)42L;
    }
    public static int AF_SMC() {
        return (int)43L;
    }
    public static int AF_XDP() {
        return (int)44L;
    }
    public static int AF_MAX() {
        return (int)45L;
    }
    public static long __SOCKADDR_COMMON_SIZE() {
        return 2L;
    }
    public static long _SS_PADSIZE() {
        return 118L;
    }
    public static int UIO_MAXIOV() {
        return (int)1024L;
    }
    public static int _STAT_VER() {
        return (int)1L;
    }
    public static int S_IFMT() {
        return (int)61440L;
    }
    public static int S_IFDIR() {
        return (int)16384L;
    }
    public static int S_IFCHR() {
        return (int)8192L;
    }
    public static int S_IFBLK() {
        return (int)24576L;
    }
    public static int S_IFREG() {
        return (int)32768L;
    }
    public static int S_IFIFO() {
        return (int)4096L;
    }
    public static int S_IFLNK() {
        return (int)40960L;
    }
    public static int S_IFSOCK() {
        return (int)49152L;
    }
    public static int S_ISUID() {
        return (int)2048L;
    }
    public static int S_ISGID() {
        return (int)1024L;
    }
    public static int S_ISVTX() {
        return (int)512L;
    }
    public static int S_IRUSR() {
        return (int)256L;
    }
    public static int S_IWUSR() {
        return (int)128L;
    }
    public static int S_IXUSR() {
        return (int)64L;
    }
    public static int S_IRWXU() {
        return (int)448L;
    }
    public static int S_IRGRP() {
        return (int)32L;
    }
    public static int S_IWGRP() {
        return (int)16L;
    }
    public static int S_IXGRP() {
        return (int)8L;
    }
    public static int S_IRWXG() {
        return (int)56L;
    }
    public static int S_IROTH() {
        return (int)4L;
    }
    public static int S_IWOTH() {
        return (int)2L;
    }
    public static int S_IXOTH() {
        return (int)1L;
    }
    public static int S_IRWXO() {
        return (int)7L;
    }
    public static int EWOULDBLOCK() {
        return (int)11L;
    }
    public static int EDEADLOCK() {
        return (int)35L;
    }

    public static int ENOTSUP() {
        return (int) 95L;
    }

    public static MemorySegment SIG_ERR() {
        return constants$36.SIG_ERR$ADDR;
    }

    public static MemorySegment SIG_DFL() {
        return constants$36.SIG_DFL$ADDR;
    }

    public static MemorySegment SIG_IGN() {
        return constants$36.SIG_IGN$ADDR;
    }



    public static int SIGIO() {
        return (int) 29L;
    }
    public static int SIGIOT() {
        return (int)6L;
    }
    public static int SIGCLD() {
        return (int)17L;
    }
    public static int _NSIG() {
        return (int)65L;
    }
    public static long _SIGSET_NWORDS() {
        return 16L;
    }
    public static int __BYTE_ORDER() {
        return (int)1234L;
    }
    public static int __FLOAT_WORD_ORDER() {
        return (int)1234L;
    }
    public static long __SI_PAD_SIZE() {
        return 28L;
    }
    public static long __SIGEV_PAD_SIZE() {
        return 12L;
    }
    public static int SA_RESETHAND() {
        return (int)2147483648L;
    }
    public static int __WCHAR_MAX() {
        return (int)2147483647L;
    }
    public static int __WCHAR_MIN() {
        return (int)-2147483648L;
    }
    public static int INT8_MIN() {
        return (int)-128L;
    }
    public static int INT16_MIN() {
        return (int)-32768L;
    }
    public static int INT32_MIN() {
        return (int)-2147483648L;
    }
    public static long INT64_MIN() {
        return -9223372036854775808L;
    }
    public static int INT8_MAX() {
        return (int)127L;
    }
    public static int INT16_MAX() {
        return (int)32767L;
    }
    public static int INT32_MAX() {
        return (int)2147483647L;
    }
    public static long INT64_MAX() {
        return 9223372036854775807L;
    }
    public static int UINT8_MAX() {
        return (int)255L;
    }
    public static int UINT16_MAX() {
        return (int)65535L;
    }
    public static int UINT32_MAX() {
        return (int)4294967295L;
    }
    public static long UINT64_MAX() {
        return -1L;
    }
    public static int INT_LEAST8_MIN() {
        return (int)-128L;
    }
    public static int INT_LEAST16_MIN() {
        return (int)-32768L;
    }
    public static int INT_LEAST32_MIN() {
        return (int)-2147483648L;
    }
    public static long INT_LEAST64_MIN() {
        return -9223372036854775808L;
    }
    public static int INT_LEAST8_MAX() {
        return (int)127L;
    }
    public static int INT_LEAST16_MAX() {
        return (int)32767L;
    }
    public static int INT_LEAST32_MAX() {
        return (int)2147483647L;
    }
    public static long INT_LEAST64_MAX() {
        return 9223372036854775807L;
    }
    public static int UINT_LEAST8_MAX() {
        return (int)255L;
    }
    public static int UINT_LEAST16_MAX() {
        return (int)65535L;
    }
    public static int UINT_LEAST32_MAX() {
        return (int)4294967295L;
    }
    public static long UINT_LEAST64_MAX() {
        return -1L;
    }
    public static int INT_FAST8_MIN() {
        return (int)-128L;
    }
    public static long INT_FAST16_MIN() {
        return -9223372036854775808L;
    }
    public static long INT_FAST32_MIN() {
        return -9223372036854775808L;
    }
    public static long INT_FAST64_MIN() {
        return -9223372036854775808L;
    }
    public static int INT_FAST8_MAX() {
        return (int)127L;
    }
    public static long INT_FAST16_MAX() {
        return 9223372036854775807L;
    }
    public static long INT_FAST32_MAX() {
        return 9223372036854775807L;
    }
    public static long INT_FAST64_MAX() {
        return 9223372036854775807L;
    }
    public static int UINT_FAST8_MAX() {
        return (int)255L;
    }
    public static long UINT_FAST16_MAX() {
        return -1L;
    }
    public static long UINT_FAST32_MAX() {
        return -1L;
    }
    public static long UINT_FAST64_MAX() {
        return -1L;
    }
    public static long INTPTR_MIN() {
        return -9223372036854775808L;
    }
    public static long INTPTR_MAX() {
        return 9223372036854775807L;
    }
    public static long UINTPTR_MAX() {
        return -1L;
    }
    public static long INTMAX_MIN() {
        return -9223372036854775808L;
    }
    public static long INTMAX_MAX() {
        return 9223372036854775807L;
    }
    public static long UINTMAX_MAX() {
        return -1L;
    }
    public static long PTRDIFF_MIN() {
        return -9223372036854775808L;
    }
    public static long PTRDIFF_MAX() {
        return 9223372036854775807L;
    }
    public static int SIG_ATOMIC_MIN() {
        return (int)-2147483648L;
    }
    public static int SIG_ATOMIC_MAX() {
        return (int)2147483647L;
    }
    public static long SIZE_MAX() {
        return -1L;
    }
    public static int WCHAR_MIN() {
        return (int)-2147483648L;
    }
    public static int WCHAR_MAX() {
        return (int)2147483647L;
    }
    public static int WINT_MIN() {
        return (int)0L;
    }
    public static int WINT_MAX() {
        return (int)4294967295L;
    }


    public static long CLOCKS_PER_SEC() {
        return 1000000L;
    }
    public static int _IOC_NRMASK() {
        return (int)255L;
    }
    public static int _IOC_TYPEMASK() {
        return (int)255L;
    }
    public static int _IOC_SIZEMASK() {
        return (int)16383L;
    }
    public static int _IOC_DIRMASK() {
        return (int)3L;
    }
    public static int _IOC_TYPESHIFT() {
        return (int)8L;
    }
    public static int _IOC_SIZESHIFT() {
        return (int)16L;
    }
    public static int _IOC_DIRSHIFT() {
        return (int)30L;
    }
    public static int _IOC_NONE() {
        return (int)0L;
    }
    public static int _IOC_WRITE() {
        return (int)1L;
    }
    public static int _IOC_READ() {
        return (int)2L;
    }
    public static int IOC_IN() {
        return (int)1073741824L;
    }
    public static int IOC_OUT() {
        return (int)2147483648L;
    }
    public static int IOC_INOUT() {
        return (int)3221225472L;
    }
    public static int IOCSIZE_MASK() {
        return (int)1073676288L;
    }
    public static int IOCSIZE_SHIFT() {
        return (int)16L;
    }

    public static long FS_IOC_SET_ENCRYPTION_POLICY() {
        return 2148296211L;
    }
    public static long FS_IOC_GET_ENCRYPTION_PWSALT() {
        return 1074816532L;
    }
    public static long FS_IOC_GET_ENCRYPTION_POLICY() {
        return 1074554389L;
    }
    public static long FS_IOC_GET_ENCRYPTION_POLICY_EX() {
        return 3221841430L;
    }
    public static long FS_IOC_ADD_ENCRYPTION_KEY() {
        return 3226494487L;
    }
    public static long FS_IOC_REMOVE_ENCRYPTION_KEY() {
        return 3225445912L;
    }
    public static long FS_IOC_REMOVE_ENCRYPTION_KEY_ALL_USERS() {
        return 3225445913L;
    }
    public static long FS_IOC_GET_ENCRYPTION_KEY_STATUS() {
        return 3229640218L;
    }
    public static int FS_KEY_DESCRIPTOR_SIZE() {
        return (int)8L;
    }
    public static int FS_POLICY_FLAGS_PAD_4() {
        return (int)0L;
    }
    public static int FS_POLICY_FLAGS_PAD_8() {
        return (int)1L;
    }
    public static int FS_POLICY_FLAGS_PAD_16() {
        return (int)2L;
    }
    public static int FS_POLICY_FLAGS_PAD_32() {
        return (int)3L;
    }
    public static int FS_POLICY_FLAGS_PAD_MASK() {
        return (int)3L;
    }
    public static int FS_POLICY_FLAG_DIRECT_KEY() {
        return (int)4L;
    }
    public static int FS_ENCRYPTION_MODE_AES_256_XTS() {
        return (int)1L;
    }
    public static int FS_ENCRYPTION_MODE_AES_256_CTS() {
        return (int)4L;
    }
    public static int FS_ENCRYPTION_MODE_AES_128_CBC() {
        return (int)5L;
    }
    public static int FS_ENCRYPTION_MODE_AES_128_CTS() {
        return (int)6L;
    }
    public static int FS_ENCRYPTION_MODE_ADIANTUM() {
        return (int)9L;
    }
    public static int FS_KEY_DESC_PREFIX_SIZE() {
        return (int)8L;
    }
    public static int FS_MAX_KEY_SIZE() {
        return (int)64L;
    }
    public static int MS_POSIXACL() {
        return (int)65536L;
    }
    public static int MS_UNBINDABLE() {
        return (int)131072L;
    }
    public static int MS_PRIVATE() {
        return (int)262144L;
    }
    public static int MS_SLAVE() {
        return (int)524288L;
    }
    public static int MS_SHARED() {
        return (int)1048576L;
    }
    public static int MS_RELATIME() {
        return (int)2097152L;
    }
    public static int MS_KERNMOUNT() {
        return (int)4194304L;
    }
    public static int MS_I_VERSION() {
        return (int)8388608L;
    }
    public static int MS_STRICTATIME() {
        return (int)16777216L;
    }
    public static int MS_LAZYTIME() {
        return (int)33554432L;
    }
    public static int MS_SUBMOUNT() {
        return (int)67108864L;
    }
    public static int MS_NOREMOTELOCK() {
        return (int)134217728L;
    }
    public static int MS_NOSEC() {
        return (int)268435456L;
    }
    public static int MS_BORN() {
        return (int)536870912L;
    }
    public static int MS_ACTIVE() {
        return (int)1073741824L;
    }
    public static int MS_NOUSER() {
        return (int)-2147483648L;
    }
    public static int MS_RMT_MASK() {
        return (int)41943121L;
    }
    public static int MS_MGC_VAL() {
        return (int)3236757504L;
    }
    public static int MS_MGC_MSK() {
        return (int)4294901760L;
    }
    public static int BLOCK_SIZE() {
        return (int)1024L;
    }
    public static int SEEK_MAX() {
        return (int)4L;
    }
    public static int RENAME_NOREPLACE() {
        return (int)1L;
    }
    public static int RENAME_EXCHANGE() {
        return (int)2L;
    }
    public static int RENAME_WHITEOUT() {
        return (int)4L;
    }
    public static int FS_XFLAG_HASATTR() {
        return (int)2147483648L;
    }
    public static int BLKROSET() {
        return (int)4701L;
    }
    public static int BLKROGET() {
        return (int)4702L;
    }
    public static int BLKRRPART() {
        return (int)4703L;
    }
    public static int BLKGETSIZE() {
        return (int)4704L;
    }
    public static int BLKFLSBUF() {
        return (int)4705L;
    }
    public static int BLKRASET() {
        return (int)4706L;
    }
    public static int BLKRAGET() {
        return (int)4707L;
    }
    public static int BLKFRASET() {
        return (int)4708L;
    }
    public static int BLKFRAGET() {
        return (int)4709L;
    }
    public static int BLKSECTSET() {
        return (int)4710L;
    }
    public static int BLKSECTGET() {
        return (int)4711L;
    }
    public static int BLKSSZGET() {
        return (int)4712L;
    }
    public static long BLKBSZGET() {
        return 2148012656L;
    }
    public static long BLKBSZSET() {
        return 1074270833L;
    }
    public static long BLKGETSIZE64() {
        return 2148012658L;
    }
    public static int BLKTRACESTART() {
        return (int)4724L;
    }
    public static int BLKTRACESTOP() {
        return (int)4725L;
    }
    public static int BLKTRACETEARDOWN() {
        return (int)4726L;
    }
    public static int BLKDISCARD() {
        return (int)4727L;
    }
    public static int BLKIOMIN() {
        return (int)4728L;
    }
    public static int BLKIOOPT() {
        return (int)4729L;
    }
    public static int BLKALIGNOFF() {
        return (int)4730L;
    }
    public static int BLKPBSZGET() {
        return (int)4731L;
    }
    public static int BLKDISCARDZEROES() {
        return (int)4732L;
    }
    public static int BLKSECDISCARD() {
        return (int)4733L;
    }
    public static int BLKROTATIONAL() {
        return (int)4734L;
    }
    public static int BLKZEROOUT() {
        return (int)4735L;
    }
    public static int FIBMAP() {
        return (int)1L;
    }
    public static int FIGETBSZ() {
        return (int)2L;
    }
    public static long FIFREEZE() {
        return 3221510263L;
    }
    public static long FITHAW() {
        return 3221510264L;
    }
    public static long FITRIM() {
        return 3222820985L;
    }
    public static long FICLONE() {
        return 1074041865L;
    }
    public static long FICLONERANGE() {
        return 1075876877L;
    }
    public static long FIDEDUPERANGE() {
        return 3222836278L;
    }
    public static long FS_IOC_GETFLAGS() {
        return 2148034049L;
    }
    public static long FS_IOC_SETFLAGS() {
        return 1074292226L;
    }
    public static long FS_IOC_GETVERSION() {
        return 2148038145L;
    }
    public static long FS_IOC_SETVERSION() {
        return 1074296322L;
    }
    public static long FS_IOC32_GETFLAGS() {
        return 2147771905L;
    }
    public static long FS_IOC32_SETFLAGS() {
        return 1074030082L;
    }
    public static long FS_IOC32_GETVERSION() {
        return 2147776001L;
    }
    public static long FS_IOC32_SETVERSION() {
        return 1074034178L;
    }
    public static long FS_IOC_FSGETXATTR() {
        return 2149341215L;
    }
    public static long FS_IOC_FSSETXATTR() {
        return 1075599392L;
    }
    public static long FS_IOC_GETFSLABEL() {
        return 2164298801L;
    }
    public static long FS_IOC_SETFSLABEL() {
        return 1090556978L;
    }
    public static int FS_RESERVED_FL() {
        return (int)2147483648L;
    }
    public static int SYNC_FILE_RANGE_WRITE_AND_WAIT() {
        return (int)7L;
    }
    public static int RWF_HIPRI() {
        return (int)1L;
    }
    public static int RWF_DSYNC() {
        return (int)2L;
    }
    public static int RWF_SYNC() {
        return (int)4L;
    }
    public static int RWF_NOWAIT() {
        return (int)8L;
    }
    public static int RWF_APPEND() {
        return (int)16L;
    }
    public static int RWF_SUPPORTED() {
        return (int)31L;
    }
    public static int IOSQE_FIXED_FILE() {
        return (int)1L;
    }
    public static int IOSQE_IO_DRAIN() {
        return (int)2L;
    }
    public static int IOSQE_IO_LINK() {
        return (int)4L;
    }
    public static int IOSQE_IO_HARDLINK() {
        return (int)8L;
    }
    public static int IOSQE_ASYNC() {
        return (int)16L;
    }
    public static int IOSQE_BUFFER_SELECT() {
        return (int)32L;
    }
    public static int IORING_SETUP_IOPOLL() {
        return (int)1L;
    }
    public static int IORING_SETUP_SQPOLL() {
        return (int)2L;
    }
    public static int IORING_SETUP_SQ_AFF() {
        return (int)4L;
    }
    public static int IORING_SETUP_CQSIZE() {
        return (int)8L;
    }

    public static int IORING_SETUP_CLAMP() {
        return (int) 16L;
    }

    public static int IORING_SETUP_ATTACH_WQ() {
        return (int) 32L;
    }

    public static int IORING_SETUP_R_DISABLED() {
        return (int) 64L;
    }

    public static int IORING_CQE_F_MORE() {
        return 2;
    }
    
    public static int IORING_FSYNC_DATASYNC() {
        return (int) 1L;
    }

    public static int IORING_TIMEOUT_ABS() {
        return (int) 1L;
    }

    public static int IORING_TIMEOUT_UPDATE() {
        return (int) 2L;
    }

    public static int SPLICE_F_FD_IN_FIXED() {
        return (int)2147483648L;
    }
    public static int IORING_CQE_F_BUFFER() {
        return (int)1L;
    }
    public static long IORING_OFF_SQ_RING() {
        return 0L;
    }
    public static long IORING_OFF_CQ_RING() {
        return 134217728L;
    }
    public static long IORING_OFF_SQES() {
        return 268435456L;
    }
    public static int IORING_SQ_NEED_WAKEUP() {
        return (int)1L;
    }
    public static int IORING_SQ_CQ_OVERFLOW() {
        return (int)2L;
    }
    public static int IORING_CQ_EVENTFD_DISABLED() {
        return (int)1L;
    }
    public static int IORING_ENTER_GETEVENTS() {
        return (int)1L;
    }
    public static int IORING_ENTER_SQ_WAKEUP() {
        return (int)2L;
    }
    public static int IORING_ENTER_SQ_WAIT() {
        return (int)4L;
    }
    public static int IORING_ENTER_EXT_ARG() {
        return (int)8L;
    }
    public static int IORING_FEAT_SINGLE_MMAP() {
        return (int)1L;
    }
    public static int IORING_FEAT_NODROP() {
        return (int)2L;
    }
    public static int IORING_FEAT_SUBMIT_STABLE() {
        return (int)4L;
    }
    public static int IORING_FEAT_RW_CUR_POS() {
        return (int)8L;
    }
    public static int IORING_FEAT_CUR_PERSONALITY() {
        return (int)16L;
    }
    public static int IORING_FEAT_FAST_POLL() {
        return (int)32L;
    }
    public static int IORING_FEAT_POLL_32BITS() {
        return (int)64L;
    }
    public static int IORING_FEAT_SQPOLL_NONFIXED() {
        return (int)128L;
    }
    public static int IORING_FEAT_EXT_ARG() {
        return (int)256L;
    }
    public static int IORING_FEAT_NATIVE_WORKERS() {
        return (int)512L;
    }
    public static int IORING_REGISTER_FILES_SKIP() {
        return (int)-2L;
    }
    public static int IO_URING_OP_SUPPORTED() {
        return (int)1L;
    }
    public static int ATOMIC_BOOL_LOCK_FREE() {
        return (int)2L;
    }
    public static int ATOMIC_CHAR_LOCK_FREE() {
        return (int)2L;
    }
    public static int ATOMIC_CHAR16_T_LOCK_FREE() {
        return (int)2L;
    }
    public static int ATOMIC_CHAR32_T_LOCK_FREE() {
        return (int)2L;
    }
    public static int ATOMIC_WCHAR_T_LOCK_FREE() {
        return (int)2L;
    }
    public static int ATOMIC_SHORT_LOCK_FREE() {
        return (int)2L;
    }
    public static int ATOMIC_INT_LOCK_FREE() {
        return (int)2L;
    }
    public static int ATOMIC_LONG_LOCK_FREE() {
        return (int)2L;
    }
    public static int ATOMIC_LLONG_LOCK_FREE() {
        return (int)2L;
    }
    public static int ATOMIC_POINTER_LOCK_FREE() {
        return (int)2L;
    }
    public static long LIBURING_UDATA_TIMEOUT() {
        return -1L;
    }
}


