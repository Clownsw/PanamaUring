// Generated by jextract

package top.dreamlike.nativeLib.mman;

import java.lang.foreign.MemorySegment;
import java.lang.invoke.MethodHandle;

import top.dreamlike.helper.RuntimeHelper;
public class mman_h {

    /* package-private */ mman_h() {
    }

    public static int MAP_32BIT() {
        return (int) 64L;
    }

    public static int MAP_GROWSDOWN() {
        return (int) 256L;
    }

    public static int MAP_DENYWRITE() {
        return (int) 2048L;
    }

    public static int MAP_EXECUTABLE() {
        return (int) 4096L;
    }

    public static int MAP_LOCKED() {
        return (int) 8192L;
    }

    public static int MAP_NORESERVE() {
        return (int) 16384L;
    }

    public static int MAP_POPULATE() {
        return (int) 32768L;
    }

    public static int MAP_NONBLOCK() {
        return (int) 65536L;
    }

    public static int MAP_STACK() {
        return (int) 131072L;
    }

    public static int MAP_HUGETLB() {
        return (int) 262144L;
    }

    public static int MAP_SYNC() {
        return (int) 524288L;
    }

    public static int MAP_FIXED_NOREPLACE() {
        return (int) 1048576L;
    }

    public static int PROT_READ() {
        return (int) 1L;
    }

    public static int PROT_WRITE() {
        return (int) 2L;
    }

    public static int PROT_EXEC() {
        return (int) 4L;
    }

    public static int PROT_NONE() {
        return (int) 0L;
    }

    public static int PROT_GROWSDOWN() {
        return (int) 16777216L;
    }

    public static int PROT_GROWSUP() {
        return (int) 33554432L;
    }

    public static int MAP_SHARED() {
        return (int) 1L;
    }

    public static int MAP_PRIVATE() {
        return (int) 2L;
    }

    public static int MAP_SHARED_VALIDATE() {
        return (int) 3L;
    }

    public static int MAP_TYPE() {
        return (int) 15L;
    }

    public static int MAP_FIXED() {
        return (int) 16L;
    }

    public static int MAP_FILE() {
        return (int) 0L;
    }

    public static int MAP_ANONYMOUS() {
        return (int) 32L;
    }

    public static int MAP_HUGE_SHIFT() {
        return (int) 26L;
    }

    public static int MAP_HUGE_MASK() {
        return (int) 63L;
    }

    public static int MS_ASYNC() {
        return (int) 1L;
    }

    public static int MS_SYNC() {
        return (int) 4L;
    }

    public static int MS_INVALIDATE() {
        return (int) 2L;
    }

    public static int MADV_NORMAL() {
        return (int) 0L;
    }

    public static int MADV_RANDOM() {
        return (int) 1L;
    }

    public static int MADV_SEQUENTIAL() {
        return (int) 2L;
    }

    public static int MADV_WILLNEED() {
        return (int) 3L;
    }

    public static int MADV_DONTNEED() {
        return (int) 4L;
    }

    public static int MADV_FREE() {
        return (int) 8L;
    }

    public static int MADV_REMOVE() {
        return (int) 9L;
    }

    public static int MADV_DONTFORK() {
        return (int) 10L;
    }

    public static int MADV_DOFORK() {
        return (int) 11L;
    }

    public static int MADV_MERGEABLE() {
        return (int) 12L;
    }

    public static int MADV_UNMERGEABLE() {
        return (int) 13L;
    }

    public static int MADV_HUGEPAGE() {
        return (int) 14L;
    }

    public static int MADV_NOHUGEPAGE() {
        return (int) 15L;
    }

    public static int MADV_DONTDUMP() {
        return (int) 16L;
    }

    public static int MADV_DODUMP() {
        return (int) 17L;
    }

    public static int MADV_WIPEONFORK() {
        return (int) 18L;
    }

    public static int MADV_KEEPONFORK() {
        return (int) 19L;
    }

    public static int MADV_COLD() {
        return (int) 20L;
    }

    public static int MADV_PAGEOUT() {
        return (int) 21L;
    }

    public static int MADV_HWPOISON() {
        return (int) 100L;
    }

    public static int POSIX_MADV_NORMAL() {
        return (int) 0L;
    }

    public static int POSIX_MADV_RANDOM() {
        return (int) 1L;
    }

    public static int POSIX_MADV_SEQUENTIAL() {
        return (int) 2L;
    }

    public static int POSIX_MADV_WILLNEED() {
        return (int) 3L;
    }

    public static int POSIX_MADV_DONTNEED() {
        return (int) 4L;
    }

    public static int MCL_CURRENT() {
        return (int) 1L;
    }

    public static int MCL_FUTURE() {
        return (int) 2L;
    }

    public static int MCL_ONFAULT() {
        return (int) 4L;
    }

    public static MethodHandle mmap$MH() {
        return RuntimeHelper.requireNonNull(constants$0.mmap$MH, "mmap");
    }

    public static MemorySegment mmap(MemorySegment __addr, long __len, int __prot, int __flags, int __fd, long __offset) {
        var mh$ = mmap$MH();
        try {
            return (java.lang.foreign.MemorySegment) mh$.invokeExact(__addr, __len, __prot, __flags, __fd, __offset);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MethodHandle munmap$MH() {
        return RuntimeHelper.requireNonNull(constants$0.munmap$MH, "munmap");
    }

    public static int munmap(MemorySegment __addr, long __len) {
        var mh$ = munmap$MH();
        try {
            return (int) mh$.invokeExact(__addr, __len);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MethodHandle mprotect$MH() {
        return RuntimeHelper.requireNonNull(constants$0.mprotect$MH, "mprotect");
    }

    public static int mprotect(MemorySegment __addr, long __len, int __prot) {
        var mh$ = mprotect$MH();
        try {
            return (int) mh$.invokeExact(__addr, __len, __prot);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MethodHandle msync$MH() {
        return RuntimeHelper.requireNonNull(constants$0.msync$MH, "msync");
    }

    public static int msync(MemorySegment __addr, long __len, int __flags) {
        var mh$ = msync$MH();
        try {
            return (int) mh$.invokeExact(__addr, __len, __flags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MethodHandle madvise$MH() {
        return RuntimeHelper.requireNonNull(constants$0.madvise$MH, "madvise");
    }

    public static int madvise(MemorySegment __addr, long __len, int __advice) {
        var mh$ = madvise$MH();
        try {
            return (int) mh$.invokeExact(__addr, __len, __advice);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MethodHandle posix_madvise$MH() {
        return RuntimeHelper.requireNonNull(constants$0.posix_madvise$MH, "posix_madvise");
    }

    public static int posix_madvise(MemorySegment __addr, long __len, int __advice) {
        var mh$ = posix_madvise$MH();
        try {
            return (int) mh$.invokeExact(__addr, __len, __advice);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MethodHandle mlock$MH() {
        return RuntimeHelper.requireNonNull(constants$1.mlock$MH, "mlock");
    }

    public static int mlock(MemorySegment __addr, long __len) {
        var mh$ = mlock$MH();
        try {
            return (int) mh$.invokeExact(__addr, __len);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MethodHandle munlock$MH() {
        return RuntimeHelper.requireNonNull(constants$1.munlock$MH, "munlock");
    }

    public static int munlock(MemorySegment __addr, long __len) {
        var mh$ = munlock$MH();
        try {
            return (int) mh$.invokeExact(__addr, __len);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MethodHandle mlockall$MH() {
        return RuntimeHelper.requireNonNull(constants$1.mlockall$MH, "mlockall");
    }

    public static int mlockall(int __flags) {
        var mh$ = mlockall$MH();
        try {
            return (int) mh$.invokeExact(__flags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MethodHandle munlockall$MH() {
        return RuntimeHelper.requireNonNull(constants$1.munlockall$MH, "munlockall");
    }

    public static int munlockall() {
        var mh$ = munlockall$MH();
        try {
            return (int) mh$.invokeExact();
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MethodHandle mincore$MH() {
        return RuntimeHelper.requireNonNull(constants$1.mincore$MH, "mincore");
    }

    public static int mincore(MemorySegment __start, long __len, MemorySegment __vec) {
        var mh$ = mincore$MH();
        try {
            return (int) mh$.invokeExact(__start, __len, __vec);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MethodHandle shm_open$MH() {
        return RuntimeHelper.requireNonNull(constants$1.shm_open$MH, "shm_open");
    }

    public static int shm_open(MemorySegment __name, int __oflag, int __mode) {
        var mh$ = shm_open$MH();
        try {
            return (int) mh$.invokeExact(__name, __oflag, __mode);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MethodHandle shm_unlink$MH() {
        return RuntimeHelper.requireNonNull(constants$2.shm_unlink$MH, "shm_unlink");
    }

    public static int shm_unlink(MemorySegment __name) {
        var mh$ = shm_unlink$MH();
        try {
            return (int) mh$.invokeExact(__name);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MemorySegment MAP_FAILED() {
        return constants$2.MAP_FAILED$ADDR;
    }
}


